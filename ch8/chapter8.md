## 练习8.1：修改clock2来接收一个端口号，写一个程序clockwall，作为多个时钟服务器的客户端，读取每一个服务器的时间，类似于不同地区办公室的时钟，然后显示在一个表中。如果可以访问不同地域的计算机，可以远程运行示例程序；否则可以伪装不同的时区，在不同的端口上本地运行：

```bash
$ TZ=US/Eastern ./clock2 -port 8010 &
$ TZ=Asia/Tokyo ./clock2 -port 8030 &
$ TZ=Europe/London ./clock2 -port 8020 &
$ clockwall NewYork=localhost:8010 London=localhost:8020 Tokyo=localhost:8030
```

## 练习8.2：实现一个并发的FTP服务器。服务器可以解释从客户端发来的命令，例如cd用来改变目录，ls用来列出目录，get用来发送一个文件的内容，close用来关闭连接。可以使用标准的ftp命令作为客户端，或者自己写一个。

## 练习8.3：在netcat3中，conn接口中有一个具体的类型*net.TCPconn，它代表一个TCP连接。TCP连接由两半边组成，可以通过CloseRead和CloseWrite方法分别关闭。修改主goroutine，仅仅关闭连接的写半边，这样程序可以继续执行来输出来自reverb1服务器的回声，即使标准输入已经关闭。（对reverb2程序来说更难一些，见练习8.4。）

## 练习8.4：修改reverb2程序来使用sync.WaitGroup来计算每一个连接上面的活动的回声goroutine的个数。当它变成0时，关闭练习8.3中描述的写半边的TCP连接。验证你修改好的netcat3客户端，等待最后几个并发的呼喊回声，即使标准输入已经关闭。

## 练习8.5：使用一个已有的CPU绑定的顺序程序，例如3.3节中的Mandelbrot程序，或者3.2节的3D平面计算，在主循环中并行执行它们，使用通道来通信。在多CPU的机器上它的运行速度有多快？goroutine的最优数量是多少？

## 练习8.6：对并发爬虫添加深度限制。如果用户设置-depth=3，那么仅最多通过三个链接可达的URL能被找到。

## 练习8.7：写一个并发程序来创建一个网站的本地镜像，获取它每一个可达的页面，然后将它们写到本地磁盘上的目录。只能获取本域的页面（例如，golang.org）。镜像页面内的URL按需调整，因为它们应该引用镜像页面，而不是原始页面。

## 练习8.8：使用select语句，给8.3节的回声服务器加一个超时，这样可以断开10s内没有任何呼叫的客户端。

## 练习8.9：写一个du版本，它可以为每一个指定的root目录计算和定期输出各自占用的总空间。

## 练习8.10：HTTP请求可以通过关闭http.Request结构中的可选的Cancel通道进行取消。修改8.6节的网页爬虫使其支持取消操作。

提示：http.Get便利函数没有提供定制Request的机会。使用http.NewRequest创建请求，设置它的Cancel字段，然后调用http.DefaultClient.Do(req)来执行请求。

## 练习8.11：使用8.4.4节的mirroredQuery程序中的方法，实现fetch的一个变种，它并发请求多个URL。当第一个响应返回的时候，取消其他请求。

## 练习8.12：让广播者在每一个新客户到来的时候通知当前存在的客户。这也要求clients集合以及entering和leaving通道记录客户的名字。

## 练习8.13：使聊天服务器可以断掉长期空置的连接，例如在过去5分钟里没有发送过消息的连接。提示：在另一个goroutine中调用conn.Close()，可以让当前阻塞的读操作变成非阻塞，就像input.Scan()输入完成的读操作一样。

## 练习8.14：改变聊天服务器的网络交互协议，让客户端可以输入它的名字。使用名字来代替网络地址作为发送者的ID，作为每一条消息的前缀。

## 练习8.15：任何客户程序读取数据的时间很长最终会造成所有的客户卡住。修改广播者，使它满足如果一个向客户写入的通道没有准备好接受它，那么跳过这条消息。还可以给每一个给向客户发送消息的通道增加缓冲，这样大多数的消息不会丢弃；广播者在这个通道上应该使用非阻塞的发送方式。
