# 第十二章 反射

- 练习12.1：扩展Display，让它可以处理map中键为结构体或者数组的情形。

- 练习12.2：通过限制递归的层数，让Display能安全处理循环引用的数据结构。（在13.3节中，我们可以看到另外一个检测循环引用的方法）

- 练习12.3：实现encode函数缺失的功能。把布尔值编码为t和nil，浮点数则用Go语言的表示法，像1+2i这种复数则编码为#C(1.0 2.0)。接口编码为成对的类型名和值，比如("[]int"{1 2 3 })，但要注意这个方法是有二义性的，因为reflect.Type.String方法可能会对不同的类型生成同样的字符串。

- 练习12.4：修改encode函数，输出如上所示的美化后的S表达式。

- 练习12.5：改写encode函数，从输出S表达式改为输出JSON。使用标准库的解码器json.Unmarshal来测试编码器。

- 练习12.6：改写encode函数，优化输出，如果字段值是其类型的零值则不须编码。

- 练习12.7：参考json.encoder（参见4.5节）的风格，创建一个S表达式编码器流式API。

- 练习12.8：类似于json.UnMarshal函数，sexpr.Unmarshal函数在解码之前就需要完整的字节slice。仿照json.Decoder，定义一个sexpr.Decoder类型，允许从一个io.Reader接口解码一系列的值。使用这个新类型来重新实现sexpr.Unmarshal。

- 练习12.9：仿照xml.Decoder（参考7.14节），写一个基于标记的S表达式解码API。你需要5个类型的标记：Symbol、String、Int、StartList和EndList。

- 练习12.10：扩展sexpr.Unmarshal，以处理练习12.3中按你的答案编码的布尔值、浮点数和接口。（提示：为了解码接口，你需要一个map，其中包含每个支持类型从名字到reflect.Type的映射。）

- 练习12.11：写一个与Unpack对应的Pack函数。给定一个结构体的值，Pack应当返回一个URL，这个URL的参数与输入的结构体对应。

- 练习12.12：扩展字段标签语法来支持参数有效性检验。比如，一个字符串应该是一个有效的email地址或者有效的信用卡号码，一个整数应当是一个有效的美国邮编。修改Unpack函数来支持这些功能。

- 练习12.13：修改S表达式编码器（参考12.4节）和解码器（参考12.6节），支持sexpr:"..."形式的字段标签，标签含义同encoding/json包（参考4.5节）。
