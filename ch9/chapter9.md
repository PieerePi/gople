# 第九章 使用共享变量实现并发

- 练习9.1：向gopl.io/ch9/bank1程序添加一个函数Withdraw(amount int)bool。结果应当反映交易成功还是由于余额不足而失败。函数发送到监控goroutine的消息应当包含取款金额和一个新的通道，这个通道用于监控goroutine把布尔型的结果发送回Withdraw函数。

- 练习9.2：重写2.6.2节的PopCount示例，使用sync.Once来把查找表的初始化延迟到第一次使用时。（从实际效果来看，像PopCount这种既小又经高度优化的函数无法承担同步的成本。）

- 练习9.3：扩展Func类型和(*Memo).Get方法，让调用者可选择性地提供一个done通道，方便取消操作（参考8.9节）。不要缓存被取消的Func调用结果。

- 练习9.4：使用通道构造一个把任意多个goroutine中联在一起的流水线程序。在内存耗尽之前你能创建的最大流水线级数是多少？一个值穿过整个流水线需要多久？

- 练习9.5：写一个程序，两个goroutine通过两个无缓冲通道来互相转发消息。这个程序能维持每秒多少次通信？

- 练习9.6：测量计算密集型并行程序（见练习8.5）在GOMAXPROCS参数变化时的性能变化。在你的计算机上最优值是多少？你的计算机有多少个CPU？
