# 第三章 基本数据

- 练习3.1：假如函数f返回一个float64型的无穷大值，就会导致SVG文件含有无效的`<polygon>`元素（尽管很多SVG绘图程序对此处理得当）。修改本程序以避免无效多边形。

- 练习3.2：用math包的其他函数试验可视化效果。你能否生成各种曲面，分别呈鸡蛋盒状、雪坡状或马鞍状？

- 练习3.3：按高度给每个多边形上色，使得峰顶呈红色（#ff0000），谷底呈蓝色（#0000ff）。

- 练习3.4：仿照1.7节的示例Lissajous的方法，构建一个Web服务器，计算并生成曲面，同时将SVG数据写入客户端。服务器必须如下设置Content-Type报头。

```go
w.Header().Set("Content-Type", "image/svg+xml")
```

（在Lissajous示例中，这一步并不强制要求，因为该服务器使用标准的启发式规则，根据响应内容最前面的512字节来识别常见的格式（如PNG），并生成正确的HTTP报头。）允许客户通过HTTP请求参数的形式指定各种值，如高度、宽度和颜色。

- 练习3.5：用image.NewRGBA函数和color.RGBA类型或color.YCbCr类型实现一个Mandelbrot集的全彩图。

- 练习3.6：超采样（supersampling）通过对几个临近像素颜色值取样并取平均值，是一种减少锯齿化的方法。最简单的做法是将每个像素分成4个“子像素”。给出实现方式。

- 练习3.7：另一种简单的分形是运用牛顿法求某个函数的复数解，比如z<sup>4</sup>-1=0。以平面上各点作为牛顿法的起始，根据逼近其中一个根（共有4个根）所需的迭代数对该点设定灰度。再根据求得的根对每个点进行全彩上色。

- 练习3.8：生成高度放大的分形需要极高的数学精度。分别用以下4种类型（complex64、complex128、big.Float和big.Rat）表示数据实现同一个分形（后面两种类型由math/big包给出。big.Float类型随意选用float32/float64浮点数，但精度有限；big.Rat类型使用无限精度的有理数。）它们在计算性能和内存消耗上相比如何？放大到什么程度，渲染的失真变得可见？

- 练习3.9：编写一个Web服务器，它生成分形并将图像数据写入客户端。要让客户端得以通过HTTP请求的参数指定x、y值和放大系数。

- 练习3.10：编写一个非递归的comma函数，运用bytes.Buffer，而不是简单的字符串拼接。

- 练习3.11：增强comma函数的功能，让其正确处理浮点数，以及带有可选正负号的数字。

- 练习3.12：编写一个函数判断两个字符串是否同文异构，也就是，它们都含有相同的字符但排列顺序不同。

- 练习3.13：用尽可能简洁的方法声明从KB、MB直到YB的常量。
